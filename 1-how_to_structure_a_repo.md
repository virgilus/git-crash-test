# Repository Structure

# Repo Structure

## Best Practices

A good program should have:

- A logical and, if possible, standardized file structure.
- Be versioned using a version control system such as GIT.
- Be easily executable through a virtual environment.
- Have unit tests to verify that program modifications do not cause regressions.

Here we will focus only on the repository structure.

Good repository (repo) structure facilitates maintenance, collaboration, and deployment. There are many ways to do this; here are the most common.

## Example of a Classic Python Repository Structure

```
my_project/
├── .gitignore
├── README.md
├── LICENSE
├── pyproject.toml (or setup.py)
├── requirements.txt
├── docs/
│   └── ...
├── tests/
│   └── ...
├── src/
│   └── my_project/
│       ├── __init__.py
│       ├── module1.py
│       └── module2.py
└── scripts/
    └── ...
```

- The most common files:
  - **`.gitignore`**: File listing files and folders to be ignored by Git.
  - **`README.md`**: Markdown file describing the project, its installation, and usage.
  - **`LICENSE`**: File containing the project's license.
  - **`requirements.txt`**: File listing the project's Python dependencies.
- Common files:
  - **`setup.py`**: Python package installation script.
  - **`pyproject.toml`**: A more modern version of "setup.py", used to specify build tools and dependencies.
  - **`download_data.py`**: Script to download data.
  - **`environment.yml`**: Usually a conda environment, works a bit like "requirements.txt" but can contain more information.
  - **`__init__.py`**: File that transforms a folder into a Python package (optional since Python 3.3)
- Frequent folders:
  - **`docs/`**: Contains the project documentation.
  - **`tests/`**: Contains unit and integration tests.
  - **`src/`**: Contains the project's source code.
  - **`notebooks/`**: Contains various notebooks (often for exploration).
  - **`models/`**: Contains various models generated by the script.
  - **`data/`**: Contains all data used by the program. The contents of this folder are often in .gitignore.

## Zoom on Some Files

### `.gitignore`

File listing files and folders to be ignored by Git. It can ignore files based on their name, extension, or the folder they are in. The "*" character represents an indefinite number of characters.

**Example**:
```
# Ignore virtual environments
venv/
.env/

# Ignore compiled Python files
__pycache__/
*.py[cod]

# Ignore local configuration files
*.env
*.ini
```

### `README.md`

Markdown file describing the project, its installation, and usage.

### `requirements.txt`

File listing the project's Python dependencies.

**Example**:
```
numpy==1.21.0
pandas==1.3.0
requests==2.26.0
flask==2.0.1
```

### `setup.py`

**Description**: Installation script defining package metadata and dependencies required for installation.

**Example**:
```python
from setuptools import setup

setup(
    name='mypackage',
    version='0.0.1',
    install_requires=[
        'requests',
        'importlib-metadata; python_version<"3.10"',
    ],
)
```

### `pyproject.toml`

A more modern version of "setup.py", used to specify build tools and dependencies.

**Example**:
```toml
[project]
name = "hello-world"
version = "1.0.0"
description = "My first Python package"
requires-python = ">=3.8"
keywords = ["python", "first-project"]
authors = [
    {name = "John Doe", email = "john@example.com"},
]
dependencies = [
    "requests",
    "gidgethub[httpx]>4.0.0",
]
```

### `download_data.py`

Script to download data.

### `environment.yml`

**Description**: Usually a conda environment stored in YAML format. Works a bit like "requirements.txt" but can contain more information.

**Example**:
```yaml
name: my_project
channels:
  - defaults
  - conda-forge
dependencies:
  - python=3.8
  - numpy=1.21.0
  - pandas=1.3.0
  - requests=2.26.0
  - pip
  - pip:
      - flask==2.0.1
      - gunicorn==20.1.0
```

### `__init__.py`

File that transforms a folder into a Python package (optional since Python 3.3).

**Example**:
```python
# __init__.py

from .module1 import my_function
from .module2 import my_class

__all__ = ["my_function", "my_class"]

__version__ = "0.1.0"
```

## Cookiecutter

[Cookiecutter](https://github.com/cookiecutter/cookiecutter) is a tool that allows you to generate project structures from templates. It is particularly useful for standardizing the structure of your Python repositories.
